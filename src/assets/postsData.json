[
  {
    "id": 1,
    "date": "2023-10-16",
    "title": "How to use the _UnhandledInput built-in function",
    "description": "The _UnhandledInput function allows for user input handling independent of signals. This short introduction offers a brief explanation to using the built-in _UnhandledInput function in Godot.",
    "content": "To handle user [input events](https://docs.godotengine.org/en/stable/tutorials/inputs/inputevent.html), such as mouse clicks or key presses, Godot provides a signal system. However, if you don't want to configure signals, there's a built-in function you can leverage: _UnhandledInput. By integrating this function into any Godot script, you can easily detect various user inputs.<br/><br/>Below is a brief code snippet from an Area3D script that listens for right-clicks. When a right-click is detected within the corresponding scene, the entire game window closes. While this example demonstrates window closure, the function can accommodate other game logic, such as transitioning to another scene or closing an overlaying window.<br/>The code example also illustrates two distinct methods for detecting user inputs. The first utilizes the user-friendly InputMap, and the second adopts a more manual tactic with @event. Although both methods are effective, the Godot documentation suggests that using InputMap is the more convenient option.",
    "code": "```csharp \nusing Godot;\nusing System;\n\npublic partial class Area3D : Godot.Area3D\n{\n\tpublic override void _Ready(){}\n\n\t// Called every frame. 'delta' is the elapsed time since the previous frame.\n\tpublic override void _Process(double delta){}\n\n\tpublic override void _UnhandledInput(InputEvent @event)\n\t{\n\t\tif (Input.IsMouseButtonPressed(MouseButton.Right))\n\t\t{\n\t\t\tGetTree().Quit();\n\t\t}\n\n\t\tif (@event is InputEventKey eventKey)\n\t\t{\n\t\t\tif (eventKey.Pressed && eventKey.Keycode == Key.Escape)\n\t\t\t{\n\t\t\t\t GetTree().Quit();\n\t\t\t}\n\t\t}\n\t}\n}",
    "codeLanguage": "C#",
    "tag": "Godot"
  },
  {
    "id": 2,
    "date": "2023-10-19",
    "title": "How to find the longest identical substring/s in two strings",
    "description": "This coding problem explanation shows how to find the longest identical substring/s in two strings with a dynamic programming approach.",
    "content": "\"In this challenge you need to implement the ```findLongestSubstring``` method which should return the longest substring of the two given strings. If there are multiple longest substrings, you should return both.<br/><br/>When ```findLongestSubstring``` is called with ```CHECKITWHEREISTHELONGESTSUBSTRING24``` and ```SUBSTINGWHERECHECKITANTCHECK24ISCHECKWHERE``` the result should be ```CHECKIT```.<br/><br/>When ```findLongestSubstring``` is called with ```247WECODEONLINEONENTWICKLERHELDDECHECKITOUT``` and ```CHECKITOUTWECODEONLINEON24ENTWICKLERHELDOUT``` the result should be ```WECODEONLINEON ENTWICKLERHELD```.<br/><br/>When ```findLongestSubstring``` is called with ```DONUTSAREDELICIOUSBUTIALSOLOVECHECK24PIZZA``` and ```PIZZASAREYUMMYBUTIDOALSOLOVEDONUTSFROMCHECK24``` the result should be ```ALSOLOVE```.<br/><br/>This should work for other examples as well.\"<br/><br/>To solve this problem, two main approaches came up my mind: the naive brute force method and the dynamic programming approach. The latter is indicated by the principle that if a problem can be solved in a smaller version (subproblems), dynamic programming might be a good fit.<br/>Here's how you can implement the dynamic programming method:<br/><br/>1. Initialization:<br/>- Instead of merely using the length of the strings, adjust for the 0-indexed nature of arrays by considering dimensions n + 1 and m + 1.<br/>- Create a 2D array (let’s call it dp) where each cell represents the count of identical characters at specific indices of the two strings. Initialize every cell with 0.<br/>- Maintain a separate array, endPoints, to note the indices of the longest identical substrings.<br/><br/>2. Processing:<br/>- Iterate through every character of the first string (string1). For each character, loop through every character of the second string (string2).<br/>- Considering the 1-indexed approach for our dp array but 0-indexed for our strings, adjust loop indices accordingly with ```i-1``` and ```j-1```.<br/>- If characters match, update the dp array by adding 1 to the value of its preceding cell: ```dp[i][j] = dp[i-1][j-1] + 1```. This process avoids recalculating values by utilizing previously calculated results.<br/>- Check if the current substring is the longest found. If it exceeds the current max, update the max value and reset the endPoints array with the new index.<br/>- If characters don’t match, set the current dp cell to 0, effectively resetting the count.<br/><br/>3. Result Generation:<br/>- Use the endPoints array to extract the longest matching substring/s from the two strings. The result can be a single or multiple substrings, depending on the characters' sequences.<br/><br/>In summary, this dynamic programming solution is efficient as it builds upon previously calculated values, reducing redundant calculations. Recognizing patterns like this in problem-solving can be crucial when tackling similar coding challenges.",
    "code": "```js \nfunction findLongestSubstring(string1, string2) {\n\t// Dynamic Programming approach with 2D array\n\tconst n = string1.length;\n\tconst m = string2.length;\n\n\t// 2D array\n\tconst dp = new Array(n + 1).fill().map(() => new Array(m + 1).fill(0));\n\n\tlet max = 0;\n\tlet endPoints = [];\n\n\tfor (let i = 1; i <= n; i++) {\n\t\tfor (let j = 1; j <= m; j++) {\n\t\t\tif (string1.charAt(i - 1) === string2.charAt(j - 1)) {\n\t\t\t\t// This way all identical substring lengths in both arrays are identified\n\t\t\t\tdp[i][j] = dp[i - 1][j - 1] + 1;\n\n\t\t\t\tif (dp[i][j] > max) {\n\t\t\t\t\tmax = dp[i][j];\n\n\t\t\t\t\t// This way the endpoint of this current identical substring is stored\n\t\t\t\t\tendPoints = [i - 1];\n\t\t\t\t} else if (dp[i][j] === max) {\n\t\t\t\t\t// This is needed since there could be multiple identical substrings, so multiple endpoints are needed as well in such cases\n\t\t\t\t\tendPoints.push(i - 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If a point is reached where the the characters don't match anymore, the current substring length starts at 0 again\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t// This way the actual strings are identified with the help of the endpoints\n\tconst substrings = endPoints.map((end => string1.substring(end - max + 1, end + 1)));\n\treturn substrings.join(\" \");\n}",
    "codeLanguage": "JavaScript",
    "tag": "Codingproblem"
  },
  {
    "id": 3,
    "date": "2021-06-01",
    "title": "Another Post",
    "description": "Quick description",
    "content": "This post is all about coding...",
    "code": "```js \npublic void helloWorld() \n{\n\tConsole.WriteLine(\"Hello World!\")\n}",
    "codeLanguage": "JavaScript",
    "tag": "Codingproblem"
  }
]
