[
  {
    "id": 1,
    "date": "2023-10-16",
    "title": "How to use the _UnhandledInput built-in function",
    "description": "The _UnhandledInput function allows for user input handling independent of signals. This short introduction offers a brief explanation to using the built-in _UnhandledInput function in Godot.",
    "content": "To handle user [input events](https://docs.godotengine.org/en/stable/tutorials/inputs/inputevent.html), such as mouse clicks or key presses, Godot provides a signal system. However, if you don't want to configure signals, there's a built-in function you can leverage: _UnhandledInput. By integrating this function into any Godot script, you can easily detect various user inputs.<br/><br/>Below is a brief code snippet from an Area3D script that listens for right-clicks. When a right-click is detected within the corresponding scene, the entire game window closes. While this example demonstrates window closure, the function can accommodate other game logic, such as transitioning to another scene or closing an overlaying window.<br/>The code example also illustrates two distinct methods for detecting user inputs. The first utilizes the user-friendly InputMap, and the second adopts a more manual tactic with @event. Although both methods are effective, the Godot documentation suggests that using InputMap is the more convenient option.",
    "code": "```csharp \nusing Godot;\nusing System;\n\npublic partial class Area3D : Godot.Area3D\n{\n\tpublic override void _Ready(){}\n\n\t// Called every frame. 'delta' is the elapsed time since the previous frame.\n\tpublic override void _Process(double delta){}\n\n\tpublic override void _UnhandledInput(InputEvent @event)\n\t{\n\t\tif (Input.IsMouseButtonPressed(MouseButton.Right))\n\t\t{\n\t\t\tGetTree().Quit();\n\t\t}\n\n\t\tif (@event is InputEventKey eventKey)\n\t\t{\n\t\t\tif (eventKey.Pressed && eventKey.Keycode == Key.Escape)\n\t\t\t{\n\t\t\t\t GetTree().Quit();\n\t\t\t}\n\t\t}\n\t}\n}",
    "codeLanguage": "C#",
    "tag": "Godot"
  },
  {
    "id": 2,
    "date": "2023-10-19",
    "title": "How to find the longest identical substring/s in two strings",
    "description": "This coding problem explanation shows how to find the longest identical substring/s in two strings with a dynamic programming approach.",
    "content": "In this [challenge](https://platform.entwicklerheld.de/challenge/longest-substring?technology=javascript) you need to implement the **findLongestSubstring** method which should return the longest substring of the two given strings. If there are multiple longest substrings, you should return both.<br/><br/>To solve this problem, two main approaches came up my mind: the naive brute force method and the dynamic programming approach. The latter is indicated by the principle that if a problem can be solved in a smaller version (subproblems), dynamic programming might be a good fit.<br/>Here's how you can implement the dynamic programming method:<br/><br/>**1. Initialization:**<br/>- Instead of merely using the length of the strings, adjust for the 0-indexed nature of arrays by considering dimensions n + 1 and m + 1.<br/>- Create a 2D array (let’s call it dp) where each cell represents the count of identical characters at specific indices of the two strings. Initialize every cell with 0.<br/>- Maintain a separate array, endPoints, to note the indices of the longest identical substrings.<br/><br/>**2. Processing:**<br/>- Iterate through every character of the first string (string1). For each character, loop through every character of the second string (string2).<br/>- Considering the 1-indexed approach for our dp array but 0-indexed for our strings, adjust loop indices accordingly with **i-1** and **j-1**.<br/>- If characters match, update the dp array by adding 1 to the value of its preceding cell: **dp[i][j] = dp[i-1][j-1] + 1**. This process avoids recalculating values by utilizing previously calculated results.<br/>- Check if the current substring is the longest found. If it exceeds the current max, update the max value and reset the endPoints array with the new index.<br/>- If characters don’t match, set the current dp cell to 0, effectively resetting the count.<br/><br/>**3. Result Generation:**<br/>- Use the endPoints array to extract the longest matching substring/s from the two strings. The result can be a single or multiple substrings, depending on the characters' sequences.<br/><br/>In summary, this dynamic programming solution is efficient as it builds upon previously calculated values, reducing redundant calculations. Recognizing patterns like this in problem-solving can be crucial when tackling similar coding challenges.",
    "code": "```js \nfunction findLongestSubstring(string1, string2) {\n\t// Dynamic Programming approach with 2D array\n\tconst n = string1.length;\n\tconst m = string2.length;\n\n\t// 2D array\n\tconst dp = new Array(n + 1).fill().map(() => new Array(m + 1).fill(0));\n\n\tlet max = 0;\n\tlet endPoints = [];\n\n\tfor (let i = 1; i <= n; i++) {\n\t\tfor (let j = 1; j <= m; j++) {\n\t\t\tif (string1.charAt(i - 1) === string2.charAt(j - 1)) {\n\t\t\t\t// This way all identical substring lengths in both arrays are identified\n\t\t\t\tdp[i][j] = dp[i - 1][j - 1] + 1;\n\n\t\t\t\tif (dp[i][j] > max) {\n\t\t\t\t\tmax = dp[i][j];\n\n\t\t\t\t\t// This way the endpoint of this current identical substring is stored\n\t\t\t\t\tendPoints = [i - 1];\n\t\t\t\t} else if (dp[i][j] === max) {\n\t\t\t\t\t// This is needed since there could be multiple identical substrings, so multiple endpoints are needed as well in such cases\n\t\t\t\t\tendPoints.push(i - 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If a point is reached where the the characters don't match anymore, the current substring length starts at 0 again\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t// This way the actual strings are identified with the help of the endpoints\n\tconst substrings = endPoints.map((end => string1.substring(end - max + 1, end + 1)));\n\treturn substrings.join(\" \");\n}",
    "codeLanguage": "JavaScript",
    "tag": "Codingproblem"
  },
  {
    "id": 3,
    "date": "2023-10-21",
    "title": "Quick Introduction to Routing",
    "description": "A quick overview of Angular's routing system serving as a quick knowledge refresher.",
    "content": "Routing is essential for configuring an effective Single Page Application (SPA). It enables the creation and management of multiple pages, known as routes, which facilitate navigation within the app. In the context of Angular, one can also utilize guards. These guards can be instrumental in granting or denying access to specific routes based on user privileges. When compared with React.js, setting up routing in an Angular application is relatively straightforward. <br /><br />In fact, upon initiating a new Angular application, you'll be prompted to decide whether an initial routing file, *app-routing.module.ts*, should be configured. This file is the hub for defining the routes you wish to integrate into your Angular app. Consider the code example below which illustrates the routing logic for a given application. Observably, there are five distinct routes. Of these, *posts*, *posts/:id*, and *about* are the primary ones. The first route serves to redirect users when they manually modify the URL, barring direct access to posts in this specific application. The ** route functions as a catch-all, handling instances where users attempt to access nonexistent paths, such as *thisWillLeadNowhere/312*.<br /><br />It's vital to note that the route linked to the NotFoundComponent doesn't cater to routes like posts/ThisIsNotAnId. In such scenarios, the dynamic *posts/:id* route would be triggered. To mitigate against these invalid routes, a catchError logic has been integrated into the corresponding service function within *SinglePostComponent*.",
    "code": "```js \nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { PostsComponent } from './components/posts/posts.component';\nimport { NotFoundComponent } from './components/not-found/not-found.component';\nimport { SinglePostComponent } from './components/single-post/single-post.component';\nimport { AboutComponent } from './components/about/about.component';\n\nexport const routes: Routes = [\n\t{ path: '', redirectTo: 'posts', pathMatch: 'full' },\n\t{ path: 'posts', component: PostsComponent },\n\t{ path: 'posts/:id', component: SinglePostComponent },\n\t{ path: 'about', component: AboutComponent },\n\t{ path: '**', component: NotFoundComponent },\n];\n\n@NgModule({\n\timports: [RouterModule.forRoot(routes)],\n\texports: [RouterModule],\n})\n\nexport class AppRoutingModule {}",
    "codeLanguage": "JavaScript",
    "tag": "Angular"
  }
]
