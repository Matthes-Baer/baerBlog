[
  {
    "id": 1,
    "date": "2023-10-16",
    "title": "How to use the _UnhandledInput built-in function",
    "description": "The _UnhandledInput function allows for user input handling independent of signals. This short introduction offers a brief explanation to using the built-in _UnhandledInput function in Godot.",
    "content": "To handle user [input events](https://docs.godotengine.org/en/stable/tutorials/inputs/inputevent.html), such as mouse clicks or key presses, Godot provides a signal system. However, if you don't want to configure signals, there's a built-in function you can leverage: _UnhandledInput. By integrating this function into any Godot script, you can easily detect various user inputs.<br/><br/>Below is a brief code snippet from an Area3D script that listens for right-clicks. When a right-click is detected within the corresponding scene, the entire game window closes. While this example demonstrates window closure, the function can accommodate other game logic, such as transitioning to another scene or closing an overlaying window.<br/>The code example also illustrates two distinct methods for detecting user inputs. The first utilizes the user-friendly InputMap, and the second adopts a more manual tactic with @event. Although both methods are effective, the Godot documentation suggests that using InputMap is the more convenient option.",
    "code": "```csharp \nusing Godot;\nusing System;\n\npublic partial class Area3D : Godot.Area3D\n{\n\tpublic override void _Ready(){}\n\n\t// Called every frame. 'delta' is the elapsed time since the previous frame.\n\tpublic override void _Process(double delta){}\n\n\tpublic override void _UnhandledInput(InputEvent @event)\n\t{\n\t\tif (Input.IsMouseButtonPressed(MouseButton.Right))\n\t\t{\n\t\t\tGetTree().Quit();\n\t\t}\n\n\t\tif (@event is InputEventKey eventKey)\n\t\t{\n\t\t\tif (eventKey.Pressed && eventKey.Keycode == Key.Escape)\n\t\t\t{\n\t\t\t\t GetTree().Quit();\n\t\t\t}\n\t\t}\n\t}\n}",
    "codeLanguage": "C#",
    "tag": "Godot"
  },
  {
    "id": 2,
    "date": "2023-10-19",
    "title": "How to find the longest identical substring/s in two strings",
    "description": "This coding problem explanation shows how to find the longest identical substring/s in two strings with a dynamic programming approach.",
    "content": "In this [challenge](https://platform.entwicklerheld.de/challenge/longest-substring?technology=javascript) you need to implement the **findLongestSubstring** method which should return the longest substring of the two given strings. If there are multiple longest substrings, you should return both.<br/><br/>To solve this problem, two main approaches came up my mind: the naive brute force method and the dynamic programming approach. The latter is indicated by the principle that if a problem can be solved in a smaller version (subproblems), dynamic programming might be a good fit.<br/>Here's how you can implement the dynamic programming method:<br/><br/>**1. Initialization:**<br/>- Instead of merely using the length of the strings, adjust for the 0-indexed nature of arrays by considering dimensions n + 1 and m + 1.<br/>- Create a 2D array (let’s call it dp) where each cell represents the count of identical characters at specific indices of the two strings. Initialize every cell with 0.<br/>- Maintain a separate array, endPoints, to note the indices of the longest identical substrings.<br/><br/>**2. Processing:**<br/>- Iterate through every character of the first string (string1). For each character, loop through every character of the second string (string2).<br/>- Considering the 1-indexed approach for our dp array but 0-indexed for our strings, adjust loop indices accordingly with **i-1** and **j-1**.<br/>- If characters match, update the dp array by adding 1 to the value of its preceding cell: **dp[i][j] = dp[i-1][j-1] + 1**. This process avoids recalculating values by utilizing previously calculated results.<br/>- Check if the current substring is the longest found. If it exceeds the current max, update the max value and reset the endPoints array with the new index.<br/>- If characters don’t match, set the current dp cell to 0, effectively resetting the count.<br/><br/>**3. Result Generation:**<br/>- Use the endPoints array to extract the longest matching substring/s from the two strings. The result can be a single or multiple substrings, depending on the characters' sequences.<br/><br/>In summary, this dynamic programming solution is efficient as it builds upon previously calculated values, reducing redundant calculations. Recognizing patterns like this in problem-solving can be crucial when tackling similar coding challenges.",
    "code": "```js \nfunction findLongestSubstring(string1, string2) {\n\t// Dynamic Programming approach with 2D array\n\tconst n = string1.length;\n\tconst m = string2.length;\n\n\t// 2D array\n\tconst dp = new Array(n + 1).fill().map(() => new Array(m + 1).fill(0));\n\n\tlet max = 0;\n\tlet endPoints = [];\n\n\tfor (let i = 1; i <= n; i++) {\n\t\tfor (let j = 1; j <= m; j++) {\n\t\t\tif (string1.charAt(i - 1) === string2.charAt(j - 1)) {\n\t\t\t\t// This way all identical substring lengths in both arrays are identified\n\t\t\t\tdp[i][j] = dp[i - 1][j - 1] + 1;\n\n\t\t\t\tif (dp[i][j] > max) {\n\t\t\t\t\tmax = dp[i][j];\n\n\t\t\t\t\t// This way the endpoint of this current identical substring is stored\n\t\t\t\t\tendPoints = [i - 1];\n\t\t\t\t} else if (dp[i][j] === max) {\n\t\t\t\t\t// This is needed since there could be multiple identical substrings, so multiple endpoints are needed as well in such cases\n\t\t\t\t\tendPoints.push(i - 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If a point is reached where the the characters don't match anymore, the current substring length starts at 0 again\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t// This way the actual strings are identified with the help of the endpoints\n\tconst substrings = endPoints.map((end => string1.substring(end - max + 1, end + 1)));\n\treturn substrings.join(\" \");\n}",
    "codeLanguage": "JavaScript",
    "tag": "Codingproblem"
  },
  {
    "id": 3,
    "date": "2023-10-21",
    "title": "Quick Introduction to Routing",
    "description": "A quick overview of Angular's routing system serving as a quick knowledge refresher for future projects.",
    "content": "Routing is essential for configuring an effective Single Page Application (SPA). It enables the creation and management of multiple pages, known as routes, which facilitate navigation within the app. In the context of Angular, one can also utilize guards. These guards can be instrumental in granting or denying access to specific routes based on user privileges. When compared with React.js, setting up routing in an Angular application is relatively straightforward. <br /><br />In fact, upon initiating a new Angular application, you'll be prompted to decide whether an initial routing file, *app-routing.module.ts*, should be configured. This file is the hub for defining the routes you wish to integrate into your Angular app. Consider the code example below which illustrates the routing logic for a given application. Observably, there are five distinct routes. Of these, *posts*, *posts/:id*, and *about* are the primary ones. The first route serves to redirect users when they manually modify the URL, barring direct access to posts in this specific application. The ** route functions as a catch-all, handling instances where users attempt to access nonexistent paths, such as *thisWillLeadNowhere/312*.<br /><br />It's vital to note that the route linked to the NotFoundComponent doesn't cater to routes like posts/ThisIsNotAnId. In such scenarios, the dynamic *posts/:id* route would be triggered. To mitigate against these invalid routes, a catchError logic has been integrated into the corresponding service function within *SinglePostComponent*.",
    "code": "```js \nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { PostsComponent } from './components/posts/posts.component';\nimport { NotFoundComponent } from './components/not-found/not-found.component';\nimport { SinglePostComponent } from './components/single-post/single-post.component';\nimport { AboutComponent } from './components/about/about.component';\n\nexport const routes: Routes = [\n\t{ path: '', redirectTo: 'posts', pathMatch: 'full' },\n\t{ path: 'posts', component: PostsComponent },\n\t{ path: 'posts/:id', component: SinglePostComponent },\n\t{ path: 'about', component: AboutComponent },\n\t{ path: '**', component: NotFoundComponent },\n];\n\n@NgModule({\n\timports: [RouterModule.forRoot(routes)],\n\texports: [RouterModule],\n})\n\nexport class AppRoutingModule {}",
    "codeLanguage": "JavaScript",
    "tag": "Angular"
  },
  {
    "id": 4,
    "date": "2023-10-23",
    "title": "How to reverse a linked list",
    "description": "This coding problem explanation illustrates an efficient approach for reversing a linked list (sourced from LeetCode).",
    "content": "Given the head of a singly linked list, reverse the list, and return the reversed list ([source](https://leetcode.com/problems/reverse-linked-list/)).<br /><br />One of the most efficient ways to reverse a linked list is illustrated below. Initially, my idea was to store all the ListNodes in an array and then iterate through that array in reverse order to construct the resulting linked list. However, this approach would not have been optimal in terms of both space and time complexity.<br /><br />Instead, you can achieve the reversal in a single loop. To do this, you'll need three elements: the current **head**, a **newHead** (initialized as null), and the **next** element (also initialized as null). These elements will be used to pass the necessary values around until **newHead** ultimately contains the reversed linked list.<br /><br />While this logic may initially seem complex or unintuitive, there's a simple pattern that can make it easier to remember. You'll loop through the linked list using the variable **head** and assign **head.next** to **next** in the first line. In the next step, you'll take the previous value on the right-hand side and assign a value to it. Similarly, for the third line, you'll use the right-hand side value from the previous line as a new element to assign a value to. This same pattern continues for the last line of the loop. By observing this consistent pattern, you'll notice that the same variable names move from one line to the next, which can be quite helpful in understanding and memorizing this logic.",
    "code": "```js \nvar reverseList = function(head) {\n\tlet newHead = null;\n\tlet next = null;\n\n\twhile (head) {\n\t\tnext = head.next;\n\t\thead.next = newHead;\n\t\tnewHead = head;\n\t\thead = next;\n\t}\n\n\treturn newHead;\n};",
    "codeLanguage": "JavaScript",
    "tag": "Codingproblem"
  },
  {
    "id": 5,
    "date": "2023-10-24",
    "title": "How to reverse a binary tree",
    "description": "This coding problem explanation illustrates an efficient approach for reversing a binary tree (sourced from LeetCode).",
    "content": "Given the root of a binary tree, invert the tree, and return its root ([source](https://leetcode.com/problems/invert-binary-tree/)).<br /><br />To reverse a binary tree, you can employ a recursive approach to recursively reverse the current level for both the left and right TreeNode from the current position. The actual swapping process is not particularly complex to grasp. You start by storing the value of **root.left** in a temporary variable (**temp** in this case). Then, you assign the value from the right side (i.e., **root.right**) to **root.left**, effectively swapping their positions.<br /><br />Now that the value of **root.left** has changed and is the same as **root.right** at this stage, you need to utilize the stored value within **temp**. With the help of **temp**, you can reassign the initial **root.left** value to **root.right**. Consequently, the left value becomes what was initially the right value, and the right value becomes what was initially the left value, effectively achieving the reversal. Since this step only reverses the current tree level, you need to dig deeper and apply this process to every TreeNode level, which is where the recursive logic comes into play. In the end, you'll have the same root structure, but with the values reversed.",
    "code": "```js \nvar invertTree = function(root) {\n\tif (!root) return null;\n\n\tlet temp = root.left;\n\troot.left = root.right;\n\troot.right = temp;\n\n\tinvertTree(root.left);\n\tinvertTree(root.right);\n\n\treturn root;\n};",
    "codeLanguage": "JavaScript",
    "tag": "Codingproblem"
  },
  {
    "id": 6,
    "date": "2023-10-28",
    "title": "Quick Introduction to Godot Signals",
    "description": "A quick overview of Godot's signals with a practical example serving as a quick knowledge refresher for future projects.",
    "content": "[Signals](https://docs.godotengine.org/en/stable/getting_started/step_by_step/signals.html) are a delegation mechanism built into Godot that allows one game object to react to a change in another without them referencing one another. Using signals limits coupling and keeps your code flexible.<br /><br />For example, you might have a life bar on the screen that represents the player's health. When the player takes damage or uses a healing potion, you want the bar to reflect the change. To do so, in Godot, you would use signals.<br /><br />Below is the script for an Area3D type in the provided code snippet. In Godot, I have added a Sprite3D and CollisionShape3D object to this Area3D object. On the Area3D object itself, you have the opportunity to add signals based on the connected CollisionObject3D. In this instance, I've added a signal for the **input_event()** and named it **OnHouseInputEvent()**. The code demonstrates how to access this signal and take actions based on it. In this specific example, a logic is implemented to load a different scene when the CollisionObject3D is clicked on, with the help of @event (The [Input singleton](https://docs.godotengine.org/en/stable/classes/class_input.html) is also a valid option and oftentimes better to implement!). Additionally, there are comments within the code that provide brief explanations of some additional details.",
    "code": "```js \nusing Godot;\nusing System;\n\npublic partial class Area3D : Godot.Area3D\n{\n\tprivate readonly PackedScene houseScene = (PackedScene)GD.Load(\"res://house.tscn\");\n\n\t// Called when the node enters the scene tree for the first time.\n\tpublic override void _Ready() {}\n\n\t// Called every frame. 'delta' is the elapsed time since the previous frame.\n\tpublic override void _Process(double delta) {}\n\n\tpublic void OnHouseInputEvent(Node camera, InputEvent @event, Vector3 position, Vector3 normal, int shape_idx)\n\t{\n\t\t// Check if the input event is a mouse button click and if it's pressed (not released).\n\t\t// This is the alternative approach with the InputMap\n\t\t// if (Input.IsMouseButtonPressed(MouseButton.Left)) {}\n\n\t\tif (@event is InputEventMouseButton eventMouseButton && eventMouseButton.Pressed)\n\t\t{\n\t\t\t// Load the house scene.\n\t\t\tNode newScene = houseScene.Instantiate();\n\n\t\t\t// Add it to the root node.\n\t\t\tGetTree().Root.AddChild(newScene);\n\n\t\t\t// Optionally, remove the current map scene from the tree.\n\t\t\tif(GetTree().CurrentScene != null)\n\t\t\t{\n\t\t\t\tGetTree().CurrentScene.Free();\n\t\t\t}\n\n\t\t\t// Set the current scene to the house scene.\n\t\t\tGetTree().CurrentScene = newScene;\n\t\t}\n\t}\n}",
    "codeLanguage": "C#",
    "tag": "Godot"
  }
]
